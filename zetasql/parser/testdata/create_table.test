create table t1 (a int32, b string);
--
CreateTableStatement [0-35]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-35]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-34]
      Identifier(b) [26-27]
      SimpleColumnSchema [28-34]
        PathExpression [28-34]
          Identifier(string) [28-34]
--
CREATE TABLE t1
(
  a int32,
  b string
)
==

create table t1 (a int32 options(option_a=1), b int64 options(option_b=2))
options(table_option=3);
--
CreateTableStatement [0-98]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-74]
    ColumnDefinition [17-44]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-44]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        OptionsList [32-44]
          OptionsEntry [33-43]
            Identifier(option_a) [33-41]
            IntLiteral(1) [42-43]
    ColumnDefinition [46-73]
      Identifier(b) [46-47]
      SimpleColumnSchema [48-73]
        PathExpression [48-53]
          Identifier(int64) [48-53]
        OptionsList [61-73]
          OptionsEntry [62-72]
            Identifier(option_b) [62-70]
            IntLiteral(2) [71-72]
  OptionsList [82-98]
    OptionsEntry [83-97]
      Identifier(table_option) [83-95]
      IntLiteral(3) [96-97]
--
CREATE TABLE t1
(
  a int32 OPTIONS(option_a = 1),
  b int64 OPTIONS(option_b = 2)
) OPTIONS(table_option = 3)
==

# Column names must be identifiers.
create table t1 (a.b.c int64);
--
ERROR: Syntax error: Unexpected "." [at 1:19]
create table t1 (a.b.c int64);
                  ^
==

# This is valid for the parser. Resolver will catch the invalid type.
create table t1 (int64 a);
--
CreateTableStatement [0-25]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-25]
    ColumnDefinition [17-24]
      Identifier(int64) [17-22]
      SimpleColumnSchema [23-24]
        PathExpression [23-24]
          Identifier(a) [23-24]
--
CREATE TABLE t1
(
  int64 a
)
==

create table t (a int32, b int64 PRIMARY KEY{{| ENFORCED| NOT ENFORCED}} OPTIONS(x=1));
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-58]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-58]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    ColumnDefinition [25-57]
      Identifier(b) [25-26]
      SimpleColumnSchema [27-57]
        PathExpression [27-32]
          Identifier(int64) [27-32]
        ColumnAttributeList [33-44]
          PrimaryKeyColumnAttribute [33-44]
        OptionsList [52-57]
          OptionsEntry [53-56]
            Identifier(x) [53-54]
            IntLiteral(1) [55-56]
--
CREATE TABLE t
(
  a int32,
  b int64 PRIMARY KEY OPTIONS(x = 1)
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-67]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-67]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    ColumnDefinition [25-66]
      Identifier(b) [25-26]
      SimpleColumnSchema [27-66]
        PathExpression [27-32]
          Identifier(int64) [27-32]
        ColumnAttributeList [33-53]
          PrimaryKeyColumnAttribute [33-53]
        OptionsList [61-66]
          OptionsEntry [62-65]
            Identifier(x) [62-63]
            IntLiteral(1) [64-65]
--
CREATE TABLE t
(
  a int32,
  b int64 PRIMARY KEY OPTIONS(x = 1)
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-71]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-71]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    ColumnDefinition [25-70]
      Identifier(b) [25-26]
      SimpleColumnSchema [27-70]
        PathExpression [27-32]
          Identifier(int64) [27-32]
        ColumnAttributeList [33-57]
          PrimaryKeyColumnAttribute [33-57]
        OptionsList [65-70]
          OptionsEntry [66-69]
            Identifier(x) [66-67]
            IntLiteral(1) [68-69]
--
CREATE TABLE t
(
  a int32,
  b int64 PRIMARY KEY NOT ENFORCED OPTIONS(x = 1)
)
==

create table t1 (a int32, b int64, c string, PRIMARY KEY(a, c){{| ENFORCED| NOT ENFORCED}});
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-63]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-63]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-33]
      Identifier(b) [26-27]
      SimpleColumnSchema [28-33]
        PathExpression [28-33]
          Identifier(int64) [28-33]
    ColumnDefinition [35-43]
      Identifier(c) [35-36]
      SimpleColumnSchema [37-43]
        PathExpression [37-43]
          Identifier(string) [37-43]
    PrimaryKey [45-62]
      ColumnList [56-62]
        Identifier(a) [57-58]
        Identifier(c) [60-61]
--
CREATE TABLE t1
(
  a int32,
  b int64,
  c string,
  PRIMARY KEY(a, c)
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-72]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-72]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-33]
      Identifier(b) [26-27]
      SimpleColumnSchema [28-33]
        PathExpression [28-33]
          Identifier(int64) [28-33]
    ColumnDefinition [35-43]
      Identifier(c) [35-36]
      SimpleColumnSchema [37-43]
        PathExpression [37-43]
          Identifier(string) [37-43]
    PrimaryKey [45-71]
      ColumnList [56-62]
        Identifier(a) [57-58]
        Identifier(c) [60-61]
--
CREATE TABLE t1
(
  a int32,
  b int64,
  c string,
  PRIMARY KEY(a, c)
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-76]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-76]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-33]
      Identifier(b) [26-27]
      SimpleColumnSchema [28-33]
        PathExpression [28-33]
          Identifier(int64) [28-33]
    ColumnDefinition [35-43]
      Identifier(c) [35-36]
      SimpleColumnSchema [37-43]
        PathExpression [37-43]
          Identifier(string) [37-43]
    PrimaryKey [45-75]
      ColumnList [56-62]
        Identifier(a) [57-58]
        Identifier(c) [60-61]
--
CREATE TABLE t1
(
  a int32,
  b int64,
  c string,
  PRIMARY KEY(a, c) NOT ENFORCED
)
==

create table t1 (a int32, PRIMARY KEY(a, c){{| ENFORCED| NOT ENFORCED}} OPTIONS(x=y), c string);
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-67]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-67]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    PrimaryKey [26-56]
      ColumnList [37-43]
        Identifier(a) [38-39]
        Identifier(c) [41-42]
      OptionsList [51-56]
        OptionsEntry [52-55]
          Identifier(x) [52-53]
          PathExpression [54-55]
            Identifier(y) [54-55]
    ColumnDefinition [58-66]
      Identifier(c) [58-59]
      SimpleColumnSchema [60-66]
        PathExpression [60-66]
          Identifier(string) [60-66]
--
CREATE TABLE t1
(
  a int32,
  PRIMARY KEY(a, c) OPTIONS(x = y),
  c string
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-76]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-76]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    PrimaryKey [26-65]
      ColumnList [37-43]
        Identifier(a) [38-39]
        Identifier(c) [41-42]
      OptionsList [60-65]
        OptionsEntry [61-64]
          Identifier(x) [61-62]
          PathExpression [63-64]
            Identifier(y) [63-64]
    ColumnDefinition [67-75]
      Identifier(c) [67-68]
      SimpleColumnSchema [69-75]
        PathExpression [69-75]
          Identifier(string) [69-75]
--
CREATE TABLE t1
(
  a int32,
  PRIMARY KEY(a, c) OPTIONS(x = y),
  c string
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-80]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-80]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    PrimaryKey [26-69]
      ColumnList [37-43]
        Identifier(a) [38-39]
        Identifier(c) [41-42]
      OptionsList [64-69]
        OptionsEntry [65-68]
          Identifier(x) [65-66]
          PathExpression [67-68]
            Identifier(y) [67-68]
    ColumnDefinition [71-79]
      Identifier(c) [71-72]
      SimpleColumnSchema [73-79]
        PathExpression [73-79]
          Identifier(string) [73-79]
--
CREATE TABLE t1
(
  a int32,
  PRIMARY KEY(a, c) NOT ENFORCED OPTIONS(x = y),
  c string
)
==

create table t1(PRIMARY KEY(x){{| ENFORCED| NOT ENFORCED}});
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-31]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [15-31]
    PrimaryKey [16-30]
      ColumnList [27-30]
        Identifier(x) [28-29]
--
CREATE TABLE t1
(
  PRIMARY KEY(x)
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-40]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [15-40]
    PrimaryKey [16-39]
      ColumnList [27-30]
        Identifier(x) [28-29]
--
CREATE TABLE t1
(
  PRIMARY KEY(x)
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-44]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [15-44]
    PrimaryKey [16-43]
      ColumnList [27-30]
        Identifier(x) [28-29]
--
CREATE TABLE t1
(
  PRIMARY KEY(x) NOT ENFORCED
)
==

create table t (a int32, PRIMARY KEY(){{| ENFORCED| NOT ENFORCED}});
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-39]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-39]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-38]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY()
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-48]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-48]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-47]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY()
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-52]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-52]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-51]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY() NOT ENFORCED
)
==

create table t (a int32, PRIMARY KEY(a){{| ENFORCED| NOT ENFORCED}} OPTIONS(x=10,y=20));
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-59]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-59]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-58]
      ColumnList [36-39]
        Identifier(a) [37-38]
      OptionsList [47-58]
        OptionsEntry [48-52]
          Identifier(x) [48-49]
          IntLiteral(10) [50-52]
        OptionsEntry [53-57]
          Identifier(y) [53-54]
          IntLiteral(20) [55-57]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY(a) OPTIONS(x = 10, y = 20)
)
--
ALTERNATION GROUP:  ENFORCED
--
CreateTableStatement [0-68]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-68]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-67]
      ColumnList [36-39]
        Identifier(a) [37-38]
      OptionsList [56-67]
        OptionsEntry [57-61]
          Identifier(x) [57-58]
          IntLiteral(10) [59-61]
        OptionsEntry [62-66]
          Identifier(y) [62-63]
          IntLiteral(20) [64-66]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY(a) OPTIONS(x = 10, y = 20)
)
--
ALTERNATION GROUP:  NOT ENFORCED
--
CreateTableStatement [0-72]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-72]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int32) [18-23]
    PrimaryKey [25-71]
      ColumnList [36-39]
        Identifier(a) [37-38]
      OptionsList [60-71]
        OptionsEntry [61-65]
          Identifier(x) [61-62]
          IntLiteral(10) [63-65]
        OptionsEntry [66-70]
          Identifier(y) [66-67]
          IntLiteral(20) [68-70]
--
CREATE TABLE t
(
  a int32,
  PRIMARY KEY(a) NOT ENFORCED OPTIONS(x = 10, y = 20)
)
==

# We do not support column list for CREATE EXTERNAL TABLE yet.
create external table t1 (a int64, b string);
--
ERROR: Syntax error: Expected keyword OPTIONS [at 1:45]
create external table t1 (a int64, b string);
                                            ^
==

# Missing type.
create table t1 (a, b string);
--
ERROR: Syntax error: Unexpected "," [at 1:19]
create table t1 (a, b string);
                  ^
==

# Missing identifier.
create table t1 (int64, b string);
--
ERROR: Syntax error: Unexpected "," [at 1:23]
create table t1 (int64, b string);
                      ^
==

# Could not resolve column options.
create table t1 (b string options(1=a));
--
ERROR: Syntax error: Unexpected integer literal "1" [at 1:35]
create table t1 (b string options(1=a));
                                  ^
==

create {{|or replace}} {{|temporary|temp}} table {{|if not exists}} T
(a int32) options ()
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-38]
  PathExpression [16-17]
    Identifier(T) [16-17]
  TableElementList [18-27]
    ColumnDefinition [19-26]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-26]
        PathExpression [21-26]
          Identifier(int32) [21-26]
  OptionsList [36-38]
--
CREATE TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: if not exists
--
CreateTableStatement(is_if_not_exists) [0-51]
  PathExpression [29-30]
    Identifier(T) [29-30]
  TableElementList [31-40]
    ColumnDefinition [32-39]
      Identifier(a) [32-33]
      SimpleColumnSchema [34-39]
        PathExpression [34-39]
          Identifier(int32) [34-39]
  OptionsList [49-51]
--
CREATE TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: temporary,
--
CreateTableStatement(is_temp) [0-47]
  PathExpression [25-26]
    Identifier(T) [25-26]
  TableElementList [27-36]
    ColumnDefinition [28-35]
      Identifier(a) [28-29]
      SimpleColumnSchema [30-35]
        PathExpression [30-35]
          Identifier(int32) [30-35]
  OptionsList [45-47]
--
CREATE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: temporary,if not exists
--
CreateTableStatement(is_temp, is_if_not_exists) [0-60]
  PathExpression [38-39]
    Identifier(T) [38-39]
  TableElementList [40-49]
    ColumnDefinition [41-48]
      Identifier(a) [41-42]
      SimpleColumnSchema [43-48]
        PathExpression [43-48]
          Identifier(int32) [43-48]
  OptionsList [58-60]
--
CREATE TEMP TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: temp,
--
CreateTableStatement(is_temp) [0-42]
  PathExpression [20-21]
    Identifier(T) [20-21]
  TableElementList [22-31]
    ColumnDefinition [23-30]
      Identifier(a) [23-24]
      SimpleColumnSchema [25-30]
        PathExpression [25-30]
          Identifier(int32) [25-30]
  OptionsList [40-42]
--
CREATE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: temp,if not exists
--
CreateTableStatement(is_temp, is_if_not_exists) [0-55]
  PathExpression [33-34]
    Identifier(T) [33-34]
  TableElementList [35-44]
    ColumnDefinition [36-43]
      Identifier(a) [36-37]
      SimpleColumnSchema [38-43]
        PathExpression [38-43]
          Identifier(int32) [38-43]
  OptionsList [53-55]
--
CREATE TEMP TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,,
--
CreateTableStatement(is_or_replace) [0-48]
  PathExpression [26-27]
    Identifier(T) [26-27]
  TableElementList [28-37]
    ColumnDefinition [29-36]
      Identifier(a) [29-30]
      SimpleColumnSchema [31-36]
        PathExpression [31-36]
          Identifier(int32) [31-36]
  OptionsList [46-48]
--
CREATE OR REPLACE TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,,if not exists
--
CreateTableStatement(is_or_replace, is_if_not_exists) [0-61]
  PathExpression [39-40]
    Identifier(T) [39-40]
  TableElementList [41-50]
    ColumnDefinition [42-49]
      Identifier(a) [42-43]
      SimpleColumnSchema [44-49]
        PathExpression [44-49]
          Identifier(int32) [44-49]
  OptionsList [59-61]
--
CREATE OR REPLACE TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,temporary,
--
CreateTableStatement(is_temp, is_or_replace) [0-57]
  PathExpression [35-36]
    Identifier(T) [35-36]
  TableElementList [37-46]
    ColumnDefinition [38-45]
      Identifier(a) [38-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int32) [40-45]
  OptionsList [55-57]
--
CREATE OR REPLACE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,temporary,if not exists
--
CreateTableStatement(is_temp, is_or_replace, is_if_not_exists) [0-70]
  PathExpression [48-49]
    Identifier(T) [48-49]
  TableElementList [50-59]
    ColumnDefinition [51-58]
      Identifier(a) [51-52]
      SimpleColumnSchema [53-58]
        PathExpression [53-58]
          Identifier(int32) [53-58]
  OptionsList [68-70]
--
CREATE OR REPLACE TEMP TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,temp,
--
CreateTableStatement(is_temp, is_or_replace) [0-52]
  PathExpression [30-31]
    Identifier(T) [30-31]
  TableElementList [32-41]
    ColumnDefinition [33-40]
      Identifier(a) [33-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int32) [35-40]
  OptionsList [50-52]
--
CREATE OR REPLACE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: or replace,temp,if not exists
--
CreateTableStatement(is_temp, is_or_replace, is_if_not_exists) [0-65]
  PathExpression [43-44]
    Identifier(T) [43-44]
  TableElementList [45-54]
    ColumnDefinition [46-53]
      Identifier(a) [46-47]
      SimpleColumnSchema [48-53]
        PathExpression [48-53]
          Identifier(int32) [48-53]
  OptionsList [63-65]
--
CREATE OR REPLACE TEMP TABLE IF NOT EXISTS T
(
  a int32
) OPTIONS()
==

create {{temporary|temp|public|private}} table T
(a int32) options ()
--
ALTERNATION GROUP: temporary
--
CreateTableStatement(is_temp) [0-45]
  PathExpression [23-24]
    Identifier(T) [23-24]
  TableElementList [25-34]
    ColumnDefinition [26-33]
      Identifier(a) [26-27]
      SimpleColumnSchema [28-33]
        PathExpression [28-33]
          Identifier(int32) [28-33]
  OptionsList [43-45]
--
CREATE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: temp
--
CreateTableStatement(is_temp) [0-40]
  PathExpression [18-19]
    Identifier(T) [18-19]
  TableElementList [20-29]
    ColumnDefinition [21-28]
      Identifier(a) [21-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
  OptionsList [38-40]
--
CREATE TEMP TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: public
--
CreateTableStatement(is_public) [0-42]
  PathExpression [20-21]
    Identifier(T) [20-21]
  TableElementList [22-31]
    ColumnDefinition [23-30]
      Identifier(a) [23-24]
      SimpleColumnSchema [25-30]
        PathExpression [25-30]
          Identifier(int32) [25-30]
  OptionsList [40-42]
--
CREATE PUBLIC TABLE T
(
  a int32
) OPTIONS()
--
ALTERNATION GROUP: private
--
CreateTableStatement(is_private) [0-43]
  PathExpression [21-22]
    Identifier(T) [21-22]
  TableElementList [23-32]
    ColumnDefinition [24-31]
      Identifier(a) [24-25]
      SimpleColumnSchema [26-31]
        PathExpression [26-31]
          Identifier(int32) [26-31]
  OptionsList [41-43]
--
CREATE PRIVATE TABLE T
(
  a int32
) OPTIONS()
==

CREATE TABLE t ();
--
ERROR: Syntax error: Expected keyword INDEX but got ")" [at 1:17]
CREATE TABLE t ();
                ^
==

create table t;
--
CreateTableStatement [0-14]
  PathExpression [13-14]
    Identifier(t) [13-14]
--
CREATE TABLE t

==

create table t (a int32, PRIMARY);
--
ERROR: Syntax error: Unexpected ")" [at 1:33]
create table t (a int32, PRIMARY);
                                ^
==

create table t (a int32, PRIMARY KEY{{| ENFORCED| NOT ENFORCED}});
--
ALTERNATION GROUP: <empty>
--
ERROR: Syntax error: Expected "(" but got ")" [at 1:37]
create table t (a int32, PRIMARY KEY);
                                    ^
--
ALTERNATION GROUP:  ENFORCED
--
ERROR: Syntax error: Expected "(" but got keyword ENFORCED [at 1:38]
create table t (a int32, PRIMARY KEY ENFORCED);
                                     ^
--
ALTERNATION GROUP:  NOT ENFORCED
--
ERROR: Syntax error: Expected "(" but got keyword NOT [at 1:38]
create table t (a int32, PRIMARY KEY NOT ENFORCED);
                                     ^
==

# TODO: This test case should work, but there is a slight awkwardness
# to create a table named "function". Writing "CREATE TABLE FUNCTION ..."
# currently parses as a CREATE TABLE FUNCTION statement, and returns an
# error because the parameter list is missing. Therefore it is necessary to add
# backticks around FUNCTION. This is a reminder to fix this parsing issue once
# we move to only having one parser.
CREATE TABLE FUNCTION (a int64);
--
ERROR: Syntax error: Unexpected "(" [at 1:23]
CREATE TABLE FUNCTION (a int64);
                      ^
==

# Creating a table named 'function' works with backticks.
CREATE TABLE `FUNCTION` (a int64);
--
CreateTableStatement [0-33]
  PathExpression [13-23]
    Identifier(`FUNCTION`) [13-23]
  TableElementList [24-33]
    ColumnDefinition [25-32]
      Identifier(a) [25-26]
      SimpleColumnSchema [27-32]
        PathExpression [27-32]
          Identifier(int64) [27-32]
--
CREATE TABLE `FUNCTION`
(
  a int64
)
==

CREATE TABLE OPTIONS(a int64);
--
CreateTableStatement [0-29]
  PathExpression [13-20]
    Identifier(OPTIONS) [13-20]
  TableElementList [20-29]
    ColumnDefinition [21-28]
      Identifier(a) [21-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int64) [23-28]
--
CREATE TABLE OPTIONS
(
  a int64
)
==

# Column being marked as hidden.
create table t1 (
  c1 int32,
  c2 int64 hidden,
  c3 string primary key
);
--
CreateTableStatement [0-74]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-74]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-47]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-47]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-47]
          HiddenColumnAttribute [41-47]
    ColumnDefinition [51-72]
      Identifier(c3) [51-53]
      SimpleColumnSchema [54-72]
        PathExpression [54-60]
          Identifier(string) [54-60]
        ColumnAttributeList [61-72]
          PrimaryKeyColumnAttribute [61-72]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 HIDDEN,
  c3 string PRIMARY KEY
)
==

# Column with both being marked as hidden and primary key (1).
create table t1 (
  c1 int32,
  c2 int64 hidden primary key{{| enforced| not enforced}},
  c3 string
);
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-74]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-74]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-59]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-59]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-59]
          HiddenColumnAttribute [41-47]
          PrimaryKeyColumnAttribute [48-59]
    ColumnDefinition [63-72]
      Identifier(c3) [63-65]
      SimpleColumnSchema [66-72]
        PathExpression [66-72]
          Identifier(string) [66-72]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 HIDDEN PRIMARY KEY,
  c3 string
)
--
ALTERNATION GROUP:  enforced
--
CreateTableStatement [0-83]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-83]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-68]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-68]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-68]
          HiddenColumnAttribute [41-47]
          PrimaryKeyColumnAttribute [48-68]
    ColumnDefinition [72-81]
      Identifier(c3) [72-74]
      SimpleColumnSchema [75-81]
        PathExpression [75-81]
          Identifier(string) [75-81]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 HIDDEN PRIMARY KEY,
  c3 string
)
--
ALTERNATION GROUP:  not enforced
--
CreateTableStatement [0-87]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-87]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-72]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-72]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-72]
          HiddenColumnAttribute [41-47]
          PrimaryKeyColumnAttribute [48-72]
    ColumnDefinition [76-85]
      Identifier(c3) [76-78]
      SimpleColumnSchema [79-85]
        PathExpression [79-85]
          Identifier(string) [79-85]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 HIDDEN PRIMARY KEY NOT ENFORCED,
  c3 string
)
==

# Column with both being marked as hidden and primary key (2).
create table t1 (
  c1 int32,
  c2 int64 primary key hidden,
  c3 string
);
--
CreateTableStatement [0-74]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-74]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-59]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-59]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-59]
          PrimaryKeyColumnAttribute [41-52]
          HiddenColumnAttribute [53-59]
    ColumnDefinition [63-72]
      Identifier(c3) [63-65]
      SimpleColumnSchema [66-72]
        PathExpression [66-72]
          Identifier(string) [66-72]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 PRIMARY KEY HIDDEN,
  c3 string
)
==

# Column being marked twice as primary key.
create table t1 (
  c1 int32,
  c2 int64 primary key{{| enforced| not enforced}} primary key,
  c3 string
);
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-79]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-79]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-64]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-64]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-64]
          PrimaryKeyColumnAttribute [41-52]
          PrimaryKeyColumnAttribute [53-64]
    ColumnDefinition [68-77]
      Identifier(c3) [68-70]
      SimpleColumnSchema [71-77]
        PathExpression [71-77]
          Identifier(string) [71-77]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 PRIMARY KEY PRIMARY KEY,
  c3 string
)
--
ALTERNATION GROUP:  enforced
--
CreateTableStatement [0-88]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-88]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-73]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-73]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-73]
          PrimaryKeyColumnAttribute [41-61]
          PrimaryKeyColumnAttribute [62-73]
    ColumnDefinition [77-86]
      Identifier(c3) [77-79]
      SimpleColumnSchema [80-86]
        PathExpression [80-86]
          Identifier(string) [80-86]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 PRIMARY KEY PRIMARY KEY,
  c3 string
)
--
ALTERNATION GROUP:  not enforced
--
CreateTableStatement [0-92]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-92]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-77]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-77]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-77]
          PrimaryKeyColumnAttribute [41-65]
          PrimaryKeyColumnAttribute [66-77]
    ColumnDefinition [81-90]
      Identifier(c3) [81-83]
      SimpleColumnSchema [84-90]
        PathExpression [84-90]
          Identifier(string) [84-90]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 PRIMARY KEY NOT ENFORCED PRIMARY KEY,
  c3 string
)
==

# Column being marked twice as hidden.
create table t1 (
  c1 int32,
  c2 int64 hidden hidden,
  c3 string
);
--
CreateTableStatement [0-69]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-69]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-54]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-54]
        PathExpression [35-40]
          Identifier(int64) [35-40]
        ColumnAttributeList [41-54]
          HiddenColumnAttribute [41-47]
          HiddenColumnAttribute [48-54]
    ColumnDefinition [58-67]
      Identifier(c3) [58-60]
      SimpleColumnSchema [61-67]
        PathExpression [61-67]
          Identifier(string) [61-67]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64 HIDDEN HIDDEN,
  c3 string
)

==

# HIDDEN attribute in STRUCT.
create table t1 (
  c1 STRUCT<x int64 hidden>
);
--

ERROR: Syntax error: Expected "," or ">" but got keyword HIDDEN [at 2:21]
  c1 STRUCT<x int64 hidden>
                    ^
==

# "HIDDEN" token in STRUCT parsed as type rather than an attribute.
create table t1 (
  c1 STRUCT<int64 hidden>
);
--

CreateTableStatement [0-45]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-45]
    ColumnDefinition [20-43]
      Identifier(c1) [20-22]
      StructColumnSchema [23-43]
        StructColumnField [30-42]
          Identifier(int64) [30-35]
          SimpleColumnSchema [36-42]
            PathExpression [36-42]
              Identifier(hidden) [36-42]
--
CREATE TABLE t1
(
  c1 STRUCT< int64 hidden >
)

==

# HIDDEN attribute in ARRAY.
create table t1 (
  c1 array<int64 hidden>
);
--

ERROR: Syntax error: Expected ">" but got keyword HIDDEN [at 2:18]
  c1 array<int64 hidden>
                 ^
==

# PRIMARY KEY attribute in STRUCT.
create table t1 (
  c1 STRUCT<x int64 primary key>
);
--

ERROR: Syntax error: Expected "," or ">" but got keyword PRIMARY [at 2:21]
  c1 STRUCT<x int64 primary key>
                    ^
==

# "PRIMARY KEY" with unnamed subfield.
create table t1 (c1 STRUCT<int64 primary key>);
--

ERROR: Syntax error: Expected "," or ">" but got keyword KEY [at 1:42]
create table t1 (c1 STRUCT<int64 primary key>);
                                         ^
==

# "PRIMARY KEY" in STRUCT parsed as name and type rather than attribute.
create table t1 (
  c1 STRUCT<primary key>
);
--

CreateTableStatement [0-44]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-44]
    ColumnDefinition [20-42]
      Identifier(c1) [20-22]
      StructColumnSchema [23-42]
        StructColumnField [30-41]
          Identifier(primary) [30-37]
          SimpleColumnSchema [38-41]
            PathExpression [38-41]
              Identifier(key) [38-41]
--
CREATE TABLE t1
(
  c1 STRUCT< primary key >
)

==

# PRIMARY KEY attribute in ARRAY.
create table t1 (
  c1 array<int64 primary key>
);
--

ERROR: Syntax error: Expected ">" but got keyword PRIMARY [at 2:18]
  c1 array<int64 primary key>
                 ^
==

# NOT NULL constraint.
create table t1 (
  c1 int32 not null,
  c2 STRUCT<x int64 not null, y bytes> not null,
  c3 STRUCT<int64, bytes not null>,
  c4 ARRAY<STRUCT<> not null>
);
--
CreateTableStatement [0-155]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-155]
    ColumnDefinition [20-37]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-37]
        PathExpression [23-28]
          Identifier(int32) [23-28]
        ColumnAttributeList [29-37]
          NotNullColumnAttribute [29-37]
    ColumnDefinition [41-86]
      Identifier(c2) [41-43]
      StructColumnSchema [44-86]
        StructColumnField [51-67]
          Identifier(x) [51-52]
          SimpleColumnSchema [53-67]
            PathExpression [53-58]
              Identifier(int64) [53-58]
            ColumnAttributeList [59-67]
              NotNullColumnAttribute [59-67]
        StructColumnField [69-76]
          Identifier(y) [69-70]
          SimpleColumnSchema [71-76]
            PathExpression [71-76]
              Identifier(bytes) [71-76]
        ColumnAttributeList [78-86]
          NotNullColumnAttribute [78-86]
    ColumnDefinition [90-122]
      Identifier(c3) [90-92]
      StructColumnSchema [93-122]
        StructColumnField [100-105]
          SimpleColumnSchema [100-105]
            PathExpression [100-105]
              Identifier(int64) [100-105]
        StructColumnField [107-121]
          SimpleColumnSchema [107-121]
            PathExpression [107-112]
              Identifier(bytes) [107-112]
            ColumnAttributeList [113-121]
              NotNullColumnAttribute [113-121]
    ColumnDefinition [126-153]
      Identifier(c4) [126-128]
      ArrayColumnSchema [129-153]
        StructColumnSchema [135-152]
          ColumnAttributeList [144-152]
            NotNullColumnAttribute [144-152]
--
CREATE TABLE t1
(
  c1 int32 NOT NULL,
  c2 STRUCT< x int64 NOT NULL, y bytes > NOT NULL,
  c3 STRUCT< int64, bytes NOT NULL >,
  c4 ARRAY< STRUCT< > NOT NULL >
)

==

# Options in fields.
create table t1 (
  c1 int32 OPTIONS(a=1),
  c2 STRUCT<x int64 OPTIONS(x=2), y bytes> OPTIONS(z=0),
  c3 STRUCT<int64, z bytes OPTIONS(y=3)>,
  c4 ARRAY<STRUCT<> OPTIONS()>
);
--
CreateTableStatement [0-174]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-174]
    ColumnDefinition [20-41]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-41]
        PathExpression [23-28]
          Identifier(int32) [23-28]
        OptionsList [36-41]
          OptionsEntry [37-40]
            Identifier(a) [37-38]
            IntLiteral(1) [39-40]
    ColumnDefinition [45-98]
      Identifier(c2) [45-47]
      StructColumnSchema [48-98]
        StructColumnField [55-75]
          Identifier(x) [55-56]
          SimpleColumnSchema [57-75]
            PathExpression [57-62]
              Identifier(int64) [57-62]
            OptionsList [70-75]
              OptionsEntry [71-74]
                Identifier(x) [71-72]
                IntLiteral(2) [73-74]
        StructColumnField [77-84]
          Identifier(y) [77-78]
          SimpleColumnSchema [79-84]
            PathExpression [79-84]
              Identifier(bytes) [79-84]
        OptionsList [93-98]
          OptionsEntry [94-97]
            Identifier(z) [94-95]
            IntLiteral(0) [96-97]
    ColumnDefinition [102-140]
      Identifier(c3) [102-104]
      StructColumnSchema [105-140]
        StructColumnField [112-117]
          SimpleColumnSchema [112-117]
            PathExpression [112-117]
              Identifier(int64) [112-117]
        StructColumnField [119-139]
          Identifier(z) [119-120]
          SimpleColumnSchema [121-139]
            PathExpression [121-126]
              Identifier(bytes) [121-126]
            OptionsList [134-139]
              OptionsEntry [135-138]
                Identifier(y) [135-136]
                IntLiteral(3) [137-138]
    ColumnDefinition [144-172]
      Identifier(c4) [144-146]
      ArrayColumnSchema [147-172]
        StructColumnSchema [153-171]
          OptionsList [169-171]
--
CREATE TABLE t1
(
  c1 int32 OPTIONS(a = 1),
  c2 STRUCT< x int64 OPTIONS(x = 2), y bytes > OPTIONS(z = 0),
  c3 STRUCT< int64, z bytes OPTIONS(y = 3) >,
  c4 ARRAY< STRUCT< > OPTIONS() >
)

==

# Options with unnamed subfield.
create table t1 (c1 STRUCT<int64 OPTIONS()>);
--

ERROR: Syntax error: Unexpected ")" [at 1:42]
create table t1 (c1 STRUCT<int64 OPTIONS()>);
                                         ^
==

# int64 is field name, OPTIONS(10) is type.
create table t1 (c1 STRUCT<int64 OPTIONS(10)>);
--
CreateTableStatement [0-46]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-46]
    ColumnDefinition [17-45]
      Identifier(c1) [17-19]
      StructColumnSchema [20-45]
        StructColumnField [27-44]
          Identifier(int64) [27-32]
          SimpleColumnSchema [33-44]
            PathExpression [33-40]
              Identifier(OPTIONS) [33-40]
            TypeParameterList [40-43]
              IntLiteral(10) [41-43]

--
CREATE TABLE t1
(
  c1 STRUCT< int64 OPTIONS(10) >
)

==

# Options with unnamed subfield and NOT NULL.
create table t1 (c1 STRUCT<int64 NOT NULL OPTIONS()>);
--

ERROR: Syntax error: Expected "," or ">" but got keyword OPTIONS [at 1:43]
create table t1 (c1 STRUCT<int64 NOT NULL OPTIONS()>);
                                          ^
==

# Options before NOT NULL in STRUCT.
create table t1 (c1 STRUCT<x int64 OPTIONS() NOT NULL>);
--

ERROR: Syntax error: Expected "," or ">" but got keyword NOT [at 1:46]
create table t1 (c1 STRUCT<x int64 OPTIONS() NOT NULL>);
                                             ^
==

# Options before NOT NULL in ARRAY.
create table t1 (c1 ARRAY<int64 OPTIONS() NOT NULL>);
--

ERROR: Syntax error: Expected ">" but got keyword NOT [at 1:43]
create table t1 (c1 ARRAY<int64 OPTIONS() NOT NULL>);
                                          ^
==

# Mixed annotations
create table t1 (
  c1 int32 not null primary key hidden OPTIONS(a=1),
  c2 STRUCT<x int64 OPTIONS(x=2), y bytes not null> OPTIONS(z=0),
  c3 STRUCT<int64, z bytes not null OPTIONS(y=3)> not null,
  c4 ARRAY<STRUCT<> not null OPTIONS()> hidden not null
);
--
CreateTableStatement [0-254]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-254]
    ColumnDefinition [20-69]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-69]
        PathExpression [23-28]
          Identifier(int32) [23-28]
        ColumnAttributeList [29-56]
          NotNullColumnAttribute [29-37]
          PrimaryKeyColumnAttribute [38-49]
          HiddenColumnAttribute [50-56]
        OptionsList [64-69]
          OptionsEntry [65-68]
            Identifier(a) [65-66]
            IntLiteral(1) [67-68]
    ColumnDefinition [73-135]
      Identifier(c2) [73-75]
      StructColumnSchema [76-135]
        StructColumnField [83-103]
          Identifier(x) [83-84]
          SimpleColumnSchema [85-103]
            PathExpression [85-90]
              Identifier(int64) [85-90]
            OptionsList [98-103]
              OptionsEntry [99-102]
                Identifier(x) [99-100]
                IntLiteral(2) [101-102]
        StructColumnField [105-121]
          Identifier(y) [105-106]
          SimpleColumnSchema [107-121]
            PathExpression [107-112]
              Identifier(bytes) [107-112]
            ColumnAttributeList [113-121]
              NotNullColumnAttribute [113-121]
        OptionsList [130-135]
          OptionsEntry [131-134]
            Identifier(z) [131-132]
            IntLiteral(0) [133-134]
    ColumnDefinition [139-195]
      Identifier(c3) [139-141]
      StructColumnSchema [142-195]
        StructColumnField [149-154]
          SimpleColumnSchema [149-154]
            PathExpression [149-154]
              Identifier(int64) [149-154]
        StructColumnField [156-185]
          Identifier(z) [156-157]
          SimpleColumnSchema [158-185]
            PathExpression [158-163]
              Identifier(bytes) [158-163]
            ColumnAttributeList [164-172]
              NotNullColumnAttribute [164-172]
            OptionsList [180-185]
              OptionsEntry [181-184]
                Identifier(y) [181-182]
                IntLiteral(3) [183-184]
        ColumnAttributeList [187-195]
          NotNullColumnAttribute [187-195]
    ColumnDefinition [199-252]
      Identifier(c4) [199-201]
      ArrayColumnSchema [202-252]
        StructColumnSchema [208-235]
          ColumnAttributeList [217-225]
            NotNullColumnAttribute [217-225]
          OptionsList [233-235]
        ColumnAttributeList [237-252]
          HiddenColumnAttribute [237-243]
          NotNullColumnAttribute [244-252]
--
CREATE TABLE t1
(
  c1 int32 NOT NULL PRIMARY KEY HIDDEN OPTIONS(a = 1),
  c2 STRUCT< x int64 OPTIONS(x = 2), y bytes NOT NULL > OPTIONS(z = 0),
  c3 STRUCT< int64, z bytes NOT NULL OPTIONS(y = 3) > NOT NULL,
  c4 ARRAY< STRUCT< > NOT NULL OPTIONS() > HIDDEN NOT NULL
)

==

# PARTITION BY
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64);
--
CreateTableStatement [0-95]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-55]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-53]
      Identifier(c3) [44-46]
      SimpleColumnSchema [47-53]
        PathExpression [47-53]
          Identifier(string) [47-53]
  PartitionBy [56-95]
    PathExpression [69-71]
      Identifier(c1) [69-71]
    BinaryExpression(+) [73-95]
      PathExpression [73-75]
        Identifier(c2) [73-75]
      CastExpression [78-95]
        PathExpression [83-85]
          Identifier(c3) [83-85]
        SimpleType [89-94]
          PathExpression [89-94]
            Identifier(int64) [89-94]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  c3 string
) PARTITION BY c1, c2 + CAST(c3 AS int64)

==

# PARTITION BY with hint (unsupported)
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition @{hint_name=5} by c1, c2 + cast(c3 as int64);
--
ERROR: Syntax error: Expected keyword BY but got "@" [at 6:11]
partition @{hint_name=5} by c1, c2 + cast(c3 as int64);
          ^
==

# PARTITION BY with column named cluster
create table t1 (
  c1 int32,
  c2 int64,
  cluster string
)
partition by cluster;
--
CreateTableStatement [0-81]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-60]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-58]
      Identifier(cluster) [44-51]
      SimpleColumnSchema [52-58]
        PathExpression [52-58]
          Identifier(string) [52-58]
  PartitionBy [61-81]
    PathExpression [74-81]
      Identifier(cluster) [74-81]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  cluster string
) PARTITION BY cluster

==

# PARTITION BY cluster CLUSTER BY cluster
create table t1 (
  c1 int32,
  c2 int64,
  cluster string
)
partition by cluster
cluster by cluster;
--
CreateTableStatement [0-100]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-60]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-58]
      Identifier(cluster) [44-51]
      SimpleColumnSchema [52-58]
        PathExpression [52-58]
          Identifier(string) [52-58]
  PartitionBy [61-81]
    PathExpression [74-81]
      Identifier(cluster) [74-81]
  ClusterBy [82-100]
    PathExpression [93-100]
      Identifier(cluster) [93-100]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  cluster string
) PARTITION BY cluster CLUSTER BY cluster

==

# PARTITION BY with OPTIONS
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
options (foo=true);
--
CreateTableStatement [0-114]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-55]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-53]
      Identifier(c3) [44-46]
      SimpleColumnSchema [47-53]
        PathExpression [47-53]
          Identifier(string) [47-53]
  PartitionBy [56-95]
    PathExpression [69-71]
      Identifier(c1) [69-71]
    BinaryExpression(+) [73-95]
      PathExpression [73-75]
        Identifier(c2) [73-75]
      CastExpression [78-95]
        PathExpression [83-85]
          Identifier(c3) [83-85]
        SimpleType [89-94]
          PathExpression [89-94]
            Identifier(int64) [89-94]
  OptionsList [104-114]
    OptionsEntry [105-113]
      Identifier(foo) [105-108]
      BooleanLiteral(true) [109-113]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  c3 string
) PARTITION BY c1, c2 + CAST(c3 AS int64) OPTIONS(foo = true)

==

# CLUSTER BY
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by c1, c2 + 5, c3;
--
CreateTableStatement [0-81]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-55]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-53]
      Identifier(c3) [44-46]
      SimpleColumnSchema [47-53]
        PathExpression [47-53]
          Identifier(string) [47-53]
  ClusterBy [56-81]
    PathExpression [67-69]
      Identifier(c1) [67-69]
    BinaryExpression(+) [71-77]
      PathExpression [71-73]
        Identifier(c2) [71-73]
      IntLiteral(5) [76-77]
    PathExpression [79-81]
      Identifier(c3) [79-81]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  c3 string
) CLUSTER BY c1, c2 + 5, c3

==

# CLUSTER BY with hint (unsupported)
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster @{hint_name=5} by c1, c2 + 5, c3;
--
ERROR: Syntax error: Expected keyword BY but got "@" [at 6:9]
cluster @{hint_name=5} by c1, c2 + 5, c3;
        ^
==

# PARTITION BY and CLUSTER BY
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
cluster by mod(c1, 2);
--
CreateTableStatement [0-117]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-55]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-53]
      Identifier(c3) [44-46]
      SimpleColumnSchema [47-53]
        PathExpression [47-53]
          Identifier(string) [47-53]
  PartitionBy [56-95]
    PathExpression [69-71]
      Identifier(c1) [69-71]
    BinaryExpression(+) [73-95]
      PathExpression [73-75]
        Identifier(c2) [73-75]
      CastExpression [78-95]
        PathExpression [83-85]
          Identifier(c3) [83-85]
        SimpleType [89-94]
          PathExpression [89-94]
            Identifier(int64) [89-94]
  ClusterBy [96-117]
    FunctionCall [107-117]
      PathExpression [107-110]
        Identifier(`mod`) [107-110]
      PathExpression [111-113]
        Identifier(c1) [111-113]
      IntLiteral(2) [115-116]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  c3 string
) PARTITION BY c1, c2 + CAST(c3 AS int64) CLUSTER BY `mod`(c1, 2)

==

# PARTITION BY and CLUSTER BY with OPTIONS
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by c1, c2 + cast(c3 as int64)
cluster by mod(c1, 2)
options (foo=true);
--
CreateTableStatement [0-136]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-55]
    ColumnDefinition [20-28]
      Identifier(c1) [20-22]
      SimpleColumnSchema [23-28]
        PathExpression [23-28]
          Identifier(int32) [23-28]
    ColumnDefinition [32-40]
      Identifier(c2) [32-34]
      SimpleColumnSchema [35-40]
        PathExpression [35-40]
          Identifier(int64) [35-40]
    ColumnDefinition [44-53]
      Identifier(c3) [44-46]
      SimpleColumnSchema [47-53]
        PathExpression [47-53]
          Identifier(string) [47-53]
  PartitionBy [56-95]
    PathExpression [69-71]
      Identifier(c1) [69-71]
    BinaryExpression(+) [73-95]
      PathExpression [73-75]
        Identifier(c2) [73-75]
      CastExpression [78-95]
        PathExpression [83-85]
          Identifier(c3) [83-85]
        SimpleType [89-94]
          PathExpression [89-94]
            Identifier(int64) [89-94]
  ClusterBy [96-117]
    FunctionCall [107-117]
      PathExpression [107-110]
        Identifier(`mod`) [107-110]
      PathExpression [111-113]
        Identifier(c1) [111-113]
      IntLiteral(2) [115-116]
  OptionsList [126-136]
    OptionsEntry [127-135]
      Identifier(foo) [127-130]
      BooleanLiteral(true) [131-135]
--
CREATE TABLE t1
(
  c1 int32,
  c2 int64,
  c3 string
) PARTITION BY c1, c2 + CAST(c3 AS int64) CLUSTER BY `mod`(c1, 2) OPTIONS(foo = true)

==

# PARTITION BY and CLUSTER BY in the wrong order
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by mod(c1, 2)
partition by c1, c2 + cast(c3 as int64)
--
ERROR: Syntax error: Expected end of input but got keyword PARTITION [at 7:1]
partition by c1, c2 + cast(c3 as int64)
^
==

# PARTITION BY with no expressions
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
partition by
--
ERROR: Syntax error: Unexpected end of statement [at 6:13]
partition by
            ^
==

# CLUSTER BY with no expressions
create table t1 (
  c1 int32,
  c2 int64,
  c3 string
)
cluster by
--
ERROR: Syntax error: Unexpected end of statement [at 6:11]
cluster by
          ^

==

# Generated Columns
create table t (
a {{|int32}} {{|GENERATED}} AS (CAST(1 as INT32)) {{|STORED VOLATILE|STORED}}
);
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-45]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-45]
    ColumnDefinition [17-42]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [21-42]
        GeneratedColumnInfo [21-42]
          CastExpression [25-41]
            IntLiteral(1) [30-31]
            SimpleType [35-40]
              PathExpression [35-40]
                Identifier(INT32) [35-40]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32))
)
--
ALTERNATION GROUP: STORED VOLATILE
--
CreateTableStatement [0-60]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-60]
    ColumnDefinition [17-58]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [21-58]
        GeneratedColumnInfo(stored_mode=STORED_VOLATILE) [21-58]
          CastExpression [25-41]
            IntLiteral(1) [30-31]
            SimpleType [35-40]
              PathExpression [35-40]
                Identifier(INT32) [35-40]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32)) STORED VOLATILE
)
--
ALTERNATION GROUP: STORED
--
CreateTableStatement [0-51]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-51]
    ColumnDefinition [17-49]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [21-49]
        GeneratedColumnInfo(stored_mode=STORED) [21-49]
          CastExpression [25-41]
            IntLiteral(1) [30-31]
            SimpleType [35-40]
              PathExpression [35-40]
                Identifier(INT32) [35-40]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32)) STORED
)
--
ALTERNATION GROUP: GENERATED,
--
CreateTableStatement [0-54]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-54]
    ColumnDefinition [17-51]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [20-51]
        GeneratedColumnInfo [20-51]
          CastExpression [34-50]
            IntLiteral(1) [39-40]
            SimpleType [44-49]
              PathExpression [44-49]
                Identifier(INT32) [44-49]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32))
)
--
ALTERNATION GROUP: GENERATED,STORED VOLATILE
--
CreateTableStatement [0-69]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-69]
    ColumnDefinition [17-67]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [20-67]
        GeneratedColumnInfo(stored_mode=STORED_VOLATILE) [20-67]
          CastExpression [34-50]
            IntLiteral(1) [39-40]
            SimpleType [44-49]
              PathExpression [44-49]
                Identifier(INT32) [44-49]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32)) STORED VOLATILE
)
--
ALTERNATION GROUP: GENERATED,STORED
--
CreateTableStatement [0-60]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-60]
    ColumnDefinition [17-58]
      Identifier(a) [17-18]
      InferredTypeColumnSchema [20-58]
        GeneratedColumnInfo(stored_mode=STORED) [20-58]
          CastExpression [34-50]
            IntLiteral(1) [39-40]
            SimpleType [44-49]
              PathExpression [44-49]
                Identifier(INT32) [44-49]
--
CREATE TABLE t
(
  a AS (CAST(1 AS INT32)) STORED
)
--
ALTERNATION GROUP: int32,,
--
CreateTableStatement [0-50]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-50]
    ColumnDefinition [17-47]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-47]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo [26-47]
          CastExpression [30-46]
            IntLiteral(1) [35-36]
            SimpleType [40-45]
              PathExpression [40-45]
                Identifier(INT32) [40-45]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32))
)
--
ALTERNATION GROUP: int32,,STORED VOLATILE
--
CreateTableStatement [0-65]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-65]
    ColumnDefinition [17-63]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-63]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo(stored_mode=STORED_VOLATILE) [26-63]
          CastExpression [30-46]
            IntLiteral(1) [35-36]
            SimpleType [40-45]
              PathExpression [40-45]
                Identifier(INT32) [40-45]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32)) STORED VOLATILE
)
--
ALTERNATION GROUP: int32,,STORED
--
CreateTableStatement [0-56]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-56]
    ColumnDefinition [17-54]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-54]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo(stored_mode=STORED) [26-54]
          CastExpression [30-46]
            IntLiteral(1) [35-36]
            SimpleType [40-45]
              PathExpression [40-45]
                Identifier(INT32) [40-45]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32)) STORED
)
--
ALTERNATION GROUP: int32,GENERATED,
--
CreateTableStatement [0-59]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-59]
    ColumnDefinition [17-56]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-56]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo [25-56]
          CastExpression [39-55]
            IntLiteral(1) [44-45]
            SimpleType [49-54]
              PathExpression [49-54]
                Identifier(INT32) [49-54]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32))
)
--
ALTERNATION GROUP: int32,GENERATED,STORED VOLATILE
--
CreateTableStatement [0-74]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-74]
    ColumnDefinition [17-72]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-72]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo(stored_mode=STORED_VOLATILE) [25-72]
          CastExpression [39-55]
            IntLiteral(1) [44-45]
            SimpleType [49-54]
              PathExpression [49-54]
                Identifier(INT32) [49-54]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32)) STORED VOLATILE
)
--
ALTERNATION GROUP: int32,GENERATED,STORED
--
CreateTableStatement [0-65]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-65]
    ColumnDefinition [17-63]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-63]
        PathExpression [19-24]
          Identifier(int32) [19-24]
        GeneratedColumnInfo(stored_mode=STORED) [25-63]
          CastExpression [39-55]
            IntLiteral(1) [44-45]
            SimpleType [49-54]
              PathExpression [49-54]
                Identifier(INT32) [49-54]
--
CREATE TABLE t
(
  a int32 AS (CAST(1 AS INT32)) STORED
)
==

# Generated Columns: Array type
create table t (
  a ARRAY<int64> AS (GENERATE_ARRAY(1, 10)),
  b AS (GENERATE_ARRAY(1, 10))
);
--
CreateTableStatement [0-94]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-94]
    ColumnDefinition [19-60]
      Identifier(a) [19-20]
      ArrayColumnSchema [21-60]
        SimpleColumnSchema [27-32]
          PathExpression [27-32]
            Identifier(int64) [27-32]
        GeneratedColumnInfo [34-60]
          FunctionCall [38-59]
            PathExpression [38-52]
              Identifier(GENERATE_ARRAY) [38-52]
            IntLiteral(1) [53-54]
            IntLiteral(10) [56-58]
    ColumnDefinition [64-92]
      Identifier(b) [64-65]
      InferredTypeColumnSchema [66-92]
        GeneratedColumnInfo [66-92]
          FunctionCall [70-91]
            PathExpression [70-84]
              Identifier(GENERATE_ARRAY) [70-84]
            IntLiteral(1) [85-86]
            IntLiteral(10) [88-90]
--
CREATE TABLE t
(
  a ARRAY< int64 > AS (GENERATE_ARRAY(1, 10)),
  b AS (GENERATE_ARRAY(1, 10))
)
==

# Generated Columns: Struct type
create table t (
  a STRUCT<int64, string> AS ((1, 'abc')),
  b AS ((1, 'abc'))
);
--
CreateTableStatement [0-81]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-81]
    ColumnDefinition [19-58]
      Identifier(a) [19-20]
      StructColumnSchema [21-58]
        StructColumnField [28-33]
          SimpleColumnSchema [28-33]
            PathExpression [28-33]
              Identifier(int64) [28-33]
        StructColumnField [35-41]
          SimpleColumnSchema [35-41]
            PathExpression [35-41]
              Identifier(string) [35-41]
        GeneratedColumnInfo [43-58]
          StructConstructorWithParens [47-57]
            IntLiteral(1) [48-49]
            StringLiteral('abc') [51-56]
    ColumnDefinition [62-79]
      Identifier(b) [62-63]
      InferredTypeColumnSchema [64-79]
        GeneratedColumnInfo [64-79]
          StructConstructorWithParens [68-78]
            IntLiteral(1) [69-70]
            StringLiteral('abc') [72-77]
--
CREATE TABLE t
(
  a STRUCT< int64, string > AS ((1, 'abc')),
  b AS ((1, 'abc'))
)
==

# Generated Columns: All the previous tests together
create table t (
  b int32 AS (CAST(1 as INT32)),
  c AS (CAST(1 as INT32)),
  d AS (CAST(1 as INT32)) STORED,
  e ARRAY<int64> AS (GENERATE_ARRAY(1, 10)),
  f STRUCT< int64, string > AS ((1, 'abc')),
  g int32 GENERATED AS (CAST(1 as INT32)),
  h GENERATED AS (CAST(1 AS INT32)) STORED VOLATILE
);
--
CreateTableStatement [0-297]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-297]
    ColumnDefinition [19-48]
      Identifier(b) [19-20]
      SimpleColumnSchema [21-48]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        GeneratedColumnInfo [27-48]
          CastExpression [31-47]
            IntLiteral(1) [36-37]
            SimpleType [41-46]
              PathExpression [41-46]
                Identifier(INT32) [41-46]
    ColumnDefinition [52-75]
      Identifier(c) [52-53]
      InferredTypeColumnSchema [54-75]
        GeneratedColumnInfo [54-75]
          CastExpression [58-74]
            IntLiteral(1) [63-64]
            SimpleType [68-73]
              PathExpression [68-73]
                Identifier(INT32) [68-73]
    ColumnDefinition [79-109]
      Identifier(d) [79-80]
      InferredTypeColumnSchema [81-109]
        GeneratedColumnInfo(stored_mode=STORED) [81-109]
          CastExpression [85-101]
            IntLiteral(1) [90-91]
            SimpleType [95-100]
              PathExpression [95-100]
                Identifier(INT32) [95-100]
    ColumnDefinition [113-154]
      Identifier(e) [113-114]
      ArrayColumnSchema [115-154]
        SimpleColumnSchema [121-126]
          PathExpression [121-126]
            Identifier(int64) [121-126]
        GeneratedColumnInfo [128-154]
          FunctionCall [132-153]
            PathExpression [132-146]
              Identifier(GENERATE_ARRAY) [132-146]
            IntLiteral(1) [147-148]
            IntLiteral(10) [150-152]
    ColumnDefinition [158-199]
      Identifier(f) [158-159]
      StructColumnSchema [160-199]
        StructColumnField [168-173]
          SimpleColumnSchema [168-173]
            PathExpression [168-173]
              Identifier(int64) [168-173]
        StructColumnField [175-181]
          SimpleColumnSchema [175-181]
            PathExpression [175-181]
              Identifier(string) [175-181]
        GeneratedColumnInfo [184-199]
          StructConstructorWithParens [188-198]
            IntLiteral(1) [189-190]
            StringLiteral('abc') [192-197]
    ColumnDefinition [203-242]
      Identifier(g) [203-204]
      SimpleColumnSchema [205-242]
        PathExpression [205-210]
          Identifier(int32) [205-210]
        GeneratedColumnInfo [211-242]
          CastExpression [225-241]
            IntLiteral(1) [230-231]
            SimpleType [235-240]
              PathExpression [235-240]
                Identifier(INT32) [235-240]
    ColumnDefinition [246-295]
      Identifier(h) [246-247]
      InferredTypeColumnSchema [248-295]
        GeneratedColumnInfo(stored_mode=STORED_VOLATILE) [248-295]
          CastExpression [262-278]
            IntLiteral(1) [267-268]
            SimpleType [272-277]
              PathExpression [272-277]
                Identifier(INT32) [272-277]
--
CREATE TABLE t
(
  b int32 AS (CAST(1 AS INT32)),
  c AS (CAST(1 AS INT32)),
  d AS (CAST(1 AS INT32)) STORED,
  e ARRAY< int64 > AS (GENERATE_ARRAY(1, 10)),
  f STRUCT< int64, string > AS ((1, 'abc')),
  g int32 AS (CAST(1 AS INT32)),
  h AS (CAST(1 AS INT32)) STORED VOLATILE
)
==

# CREATE TABLE LIKE
create table t LIKE t1;
--
CreateTableStatement [0-22]
  PathExpression [13-14]
    Identifier(t) [13-14]
  PathExpression [20-22]
    Identifier(t1) [20-22]
--
CREATE TABLE t LIKE
t1
==

create external table t LIKE t1 OPTIONS();
--
CreateExternalTableStatement [0-41]
  PathExpression [22-23]
    Identifier(t) [22-23]
  PathExpression [29-31]
    Identifier(t1) [29-31]
  OptionsList [39-41]
--
CREATE EXTERNAL TABLE t LIKE
t1 OPTIONS()
==

# CREATE TABLE LIKE with column list, valid for parser and Resolver will catch
# the co-existence of LIKE and column list.
create table t (x int64) LIKE t1;
--
CreateTableStatement [0-32]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-24]
    ColumnDefinition [16-23]
      Identifier(x) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int64) [18-23]
  PathExpression [30-32]
    Identifier(t1) [30-32]
--
CREATE TABLE t
(
  x int64
) LIKE
t1
==

# CREATE TABLE LIKE without table name.
create table t like;
--
ERROR: Syntax error: Unexpected ";" [at 1:20]
create table t like;
                   ^
==

# Column default value is turned off
[{{no_|}}allow_column_default_value]
CREATE TABLE t
(
  a int32 DEFAULT 1
)
--
ALTERNATION GROUP: no_
--
ERROR: Column DEFAULT value is not supported. [at 3:19]
  a int32 DEFAULT 1
                  ^
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-38]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-38]
    ColumnDefinition [19-36]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-36]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        IntLiteral(1) [35-36]
--
CREATE TABLE t
(
  a int32 DEFAULT 1
)
==

# A column with both generation and default clause (disallowed)
CREATE TABLE t
(
  a int32 AS (1) DEFAULT 2
)
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 3:18]
  a int32 AS (1) DEFAULT 2
                 ^
==

# A column with multiple default clauses (disallowed) -- grammar / message check
CREATE TABLE t
(
  a int32 DEFAULT 2 DEFAULT 2
)
--
ERROR: Syntax error: Expected ")" or "," but got keyword DEFAULT [at 3:21]
  a int32 DEFAULT 2 DEFAULT 2
                    ^
==

# A column with multiple AS clauses (disallowed) -- grammar / message check
CREATE TABLE t
(
  a int32 AS (1) AS (2)
)
--
ERROR: Syntax error: Expected ")" or "," but got keyword AS [at 3:18]
  a int32 AS (1) AS (2)
                 ^
==

# Another column with both generation and default clause (disallowed)
CREATE TABLE t
(
  d int32 DEFAULT 2 AS (CAST(1 AS INT32)) STORED
)
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 3:21]
  d int32 DEFAULT 2 AS (CAST(1 AS INT32)) STORED
                    ^
==

# An array column with both generation and default clause (disallowed)
CREATE TABLE t
(
  e ARRAY< int64 > AS (GENERATE_ARRAY(1, 10)) DEFAULT (GENERATE_ARRAY(1, 10))
)
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 3:47]
  e ARRAY< int64 > AS (GENERATE_ARRAY(1, 10)) DEFAULT (GENERATE_ARRAY(1, 10))
                                              ^
==

# A struct column with both generation and default clause (disallowed)
CREATE TABLE t
(
  f STRUCT< int64, string > DEFAULT (3, 'def') AS ((1, 'abc'))
)
--
ERROR: Syntax error: "DEFAULT" and "GENERATED ALWAYS AS" clauses must not be both provided for the column [at 3:48]
  f STRUCT< int64, string > DEFAULT (3, 'def') AS ((1, 'abc'))
                                               ^
==

# A column with inferred type and 1 as default value (disallowed)
CREATE TABLE t
(
  b DEFAULT 1
)
--
ERROR: Syntax error: Unexpected keyword DEFAULT [at 3:5]
  b DEFAULT 1
    ^
==

# Columns with default values
CREATE TABLE t
(
  a int32 DEFAULT 1,
  b int32 DEFAULT CAST(1 AS INT32),
  c ARRAY< int64 > DEFAULT GENERATE_ARRAY(1, 10),
  d STRUCT< int64, string > DEFAULT (1, 'abc')
)
--
CreateTableStatement [0-172]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-172]
    ColumnDefinition [19-36]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-36]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        IntLiteral(1) [35-36]
    ColumnDefinition [40-72]
      Identifier(b) [40-41]
      SimpleColumnSchema [42-72]
        PathExpression [42-47]
          Identifier(int32) [42-47]
        CastExpression [56-72]
          IntLiteral(1) [61-62]
          SimpleType [66-71]
            PathExpression [66-71]
              Identifier(INT32) [66-71]
    ColumnDefinition [76-122]
      Identifier(c) [76-77]
      ArrayColumnSchema [78-122]
        SimpleColumnSchema [85-90]
          PathExpression [85-90]
            Identifier(int64) [85-90]
        FunctionCall [101-122]
          PathExpression [101-115]
            Identifier(GENERATE_ARRAY) [101-115]
          IntLiteral(1) [116-117]
          IntLiteral(10) [119-121]
    ColumnDefinition [126-170]
      Identifier(d) [126-127]
      StructColumnSchema [128-170]
        StructColumnField [136-141]
          SimpleColumnSchema [136-141]
            PathExpression [136-141]
              Identifier(int64) [136-141]
        StructColumnField [143-149]
          SimpleColumnSchema [143-149]
            PathExpression [143-149]
              Identifier(string) [143-149]
        StructConstructorWithParens [160-170]
          IntLiteral(1) [161-162]
          StringLiteral('abc') [164-169]
--
CREATE TABLE t
(
  a int32 DEFAULT 1,
  b int32 DEFAULT CAST(1 AS INT32),
  c ARRAY< int64 > DEFAULT GENERATE_ARRAY(1, 10),
  d STRUCT< int64, string > DEFAULT (1, 'abc')
)
==

# Column default value and table check constraint
CREATE TABLE t
(
  a int32 DEFAULT 1,
  check (a > 0)
)
--
CreateTableStatement [0-55]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-55]
    ColumnDefinition [19-36]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-36]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        IntLiteral(1) [35-36]
    CheckConstraint(ENFORCED) [40-53]
      BinaryExpression(>) [47-52]
        PathExpression [47-48]
          Identifier(a) [47-48]
        IntLiteral(0) [51-52]
--
CREATE TABLE t
(
  a int32 DEFAULT 1,
  CHECK(a > 0) ENFORCED
)
==

# Column default value and a not enforced check constraint
CREATE TABLE t
(
  a int32 DEFAULT 1,
  check (a > 0) not enforced,
)
--
CreateTableStatement [0-69]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-69]
    ColumnDefinition [19-36]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-36]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        IntLiteral(1) [35-36]
    CheckConstraint(NOT ENFORCED) [40-66]
      BinaryExpression(>) [47-52]
        PathExpression [47-48]
          Identifier(a) [47-48]
        IntLiteral(0) [51-52]
--
CREATE TABLE t
(
  a int32 DEFAULT 1,
  CHECK(a > 0) NOT ENFORCED
)
==

# Column default value and a not null attribute
CREATE TABLE t
(
  a int32 DEFAULT 1 NOT NULL,
)
--
CreateTableStatement [0-48]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-48]
    ColumnDefinition [19-45]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-45]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        IntLiteral(1) [35-36]
        ColumnAttributeList [37-45]
          NotNullColumnAttribute [37-45]
--
CREATE TABLE t
(
  a int32 DEFAULT 1 NOT NULL
)
==

# Column null default value and a not null attribute
CREATE TABLE t
(
  a int32 DEFAULT NULL NOT NULL,
)
--
CreateTableStatement [0-51]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-51]
    ColumnDefinition [19-48]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-48]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        NullLiteral(NULL) [35-39]
        ColumnAttributeList [40-48]
          NotNullColumnAttribute [40-48]
--
CREATE TABLE t
(
  a int32 DEFAULT NULL NOT NULL
)
==

# Column not null default value and a not null attribute
CREATE TABLE t
(
  a int32 DEFAULT NOT NULL NOT NULL
)
--
CreateTableStatement [0-54]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-54]
    ColumnDefinition [19-52]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-52]
        PathExpression [21-26]
          Identifier(int32) [21-26]
        UnaryExpression(NOT) [35-43]
          NullLiteral(NULL) [39-43]
        ColumnAttributeList [44-52]
          NotNullColumnAttribute [44-52]
--
CREATE TABLE t
(
  a int32 DEFAULT NOT NULL NOT NULL
)
==

# Foreign key column and table constraints.
create table t (
  a int64,
  b int64
    hidden
    constraint f
      references p (q)
      match full
      on update restrict
      on delete cascade
      enforced
    options (),
  primary key (a),
  constraint c
    foreign key (a, b)
    references r.s.t (c, d)
    match simple
    on update set null
    on delete no action
    not enforced
    options ());
--
CreateTableStatement [0-367]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-367]
    ColumnDefinition [19-26]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-26]
        PathExpression [21-26]
          Identifier(int64) [21-26]
    ColumnDefinition [30-184]
      Identifier(b) [30-31]
      SimpleColumnSchema [32-184]
        PathExpression [32-37]
          Identifier(int64) [32-37]
        ColumnAttributeList [42-169]
          HiddenColumnAttribute [42-48]
          ForeignKeyColumnAttribute [53-169]
            Identifier(f) [64-65]
            ForeignKeyReference(MATCH FULL ENFORCED) [72-154]
              PathExpression [83-84]
                Identifier(p) [83-84]
              ColumnList [85-88]
                Identifier(q) [86-87]
              ForeignKeyActions(ON UPDATE RESTRICT ON DELETE CASCADE) [112-154]
        OptionsList [182-184]
    PrimaryKey [188-203]
      ColumnList [200-203]
        Identifier(a) [201-202]
    ForeignKey [207-366]
      ColumnList [236-242]
        Identifier(a) [237-238]
        Identifier(b) [240-241]
      ForeignKeyReference(MATCH SIMPLE NOT ENFORCED) [247-334]
        PathExpression [258-263]
          Identifier(r) [258-259]
          Identifier(s) [260-261]
          Identifier(t) [262-263]
        ColumnList [264-270]
          Identifier(c) [265-266]
          Identifier(d) [268-269]
        ForeignKeyActions(ON UPDATE SET NULL ON DELETE NO ACTION) [292-334]
      OptionsList [364-366]
      Identifier(c) [218-219]
--
CREATE TABLE t
(
  a int64,
  b int64 HIDDEN CONSTRAINT f REFERENCES p(q) MATCH FULL ON UPDATE RESTRICT ON DELETE CASCADE ENFORCED OPTIONS(),
  PRIMARY KEY(a),
  CONSTRAINT c FOREIGN KEY(a, b) REFERENCES r.s.t(c, d) MATCH SIMPLE ON UPDATE SET NULL ON DELETE NO ACTION NOT ENFORCED OPTIONS()
)
==

# PRIMARY, FOREIGN, and KEY are valid identifiers.
create table t (primary int64, foreign int64, a key);
--
CreateTableStatement [0-52]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-52]
    ColumnDefinition [16-29]
      Identifier(primary) [16-23]
      SimpleColumnSchema [24-29]
        PathExpression [24-29]
          Identifier(int64) [24-29]
    ColumnDefinition [31-44]
      Identifier(foreign) [31-38]
      SimpleColumnSchema [39-44]
        PathExpression [39-44]
          Identifier(int64) [39-44]
    ColumnDefinition [46-51]
      Identifier(a) [46-47]
      SimpleColumnSchema [48-51]
        PathExpression [48-51]
          Identifier(key) [48-51]
--
CREATE TABLE t
(
  primary int64,
  foreign int64,
  a key
)
==

# create table with index definition
# single key 
create table t (c1 int32, c2 string, c3 int64, index(key=c2, ts=c3));
--
CreateTableStatement [0-68]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-68]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-67]
      OptionsList [52-67]
        OptionsEntry [53-59]
          Identifier(key) [53-56]
          PathExpression [57-59]
            Identifier(c2) [57-59]
        OptionsEntry [61-66]
          Identifier(ts) [61-63]
          PathExpression [64-66]
            Identifier(c3) [64-66]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = c2, ts = c3)
)
==

# create table with index definition
# multiple keys
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3));
--
CreateTableStatement [0-73]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-73]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-72]
      OptionsList [52-72]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3)
)
==

# create table with index definition
# multiple keys, ttl_type = absolute
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3, ttl_type=absolute));
--
CreateTableStatement [0-92]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-92]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-91]
      OptionsList [52-91]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
        OptionsEntry [73-90]
          Identifier(ttl_type) [73-81]
          PathExpression [82-90]
            Identifier(absolute) [82-90]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3, ttl_type = absolute)
)
==

# create table with index definition
# multiple keys, ttl_type = absolute, ttl = 365d
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3, ttl_type=absolute, ttl=356d));
--
CreateTableStatement [0-102]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-102]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-101]
      OptionsList [52-101]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
        OptionsEntry [73-90]
          Identifier(ttl_type) [73-81]
          PathExpression [82-90]
            Identifier(absolute) [82-90]
        OptionsEntry [92-100]
          Identifier(ttl) [92-95]
          IntervalLiteral(356d) [96-100]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3, ttl_type = absolute, ttl = 356d)
)
==

# create table with index definition
# multiple keys, ttl_type = latest, ttl = 0
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3, ttl_type=latest, ttl=0));
--
CreateTableStatement [0-97]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-97]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-96]
      OptionsList [52-96]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
        OptionsEntry [73-88]
          Identifier(ttl_type) [73-81]
          PathExpression [82-88]
            Identifier(latest) [82-88]
        OptionsEntry [90-95]
          Identifier(ttl) [90-93]
          IntLiteral(0) [94-95]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3, ttl_type = latest, ttl = 0)
)
==

# create table with index definition
# multiple keys, ttl_type = absandlat, ttl = (10d,100)
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3, ttl_type=absandlat, ttl=(10d, 100)));
--
CreateTableStatement [0-109]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-109]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-108]
      OptionsList [52-108]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
        OptionsEntry [73-91]
          Identifier(ttl_type) [73-81]
          PathExpression [82-91]
            Identifier(absandlat) [82-91]
        OptionsEntry [93-107]
          Identifier(ttl) [93-96]
          StructConstructorWithParens [97-107]
            IntervalLiteral(10d) [98-101]
            IntLiteral(100) [103-106]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3, ttl_type = absandlat, ttl = (10d, 100))
)
==

# create table with index definition
# multiple keys, ttl_type = absorlat, ttl = (10d,100)
create table t (c1 int32, c2 string, c3 int64, index(key=(c1,c2), ts=c3, ttl_type=absorlat, ttl=(10d, 100)));
--
CreateTableStatement [0-108]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-108]
    ColumnDefinition [16-24]
      Identifier(c1) [16-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int32) [19-24]
    ColumnDefinition [26-35]
      Identifier(c2) [26-28]
      SimpleColumnSchema [29-35]
        PathExpression [29-35]
          Identifier(string) [29-35]
    ColumnDefinition [37-45]
      Identifier(c3) [37-39]
      SimpleColumnSchema [40-45]
        PathExpression [40-45]
          Identifier(int64) [40-45]
    IndexDefinition [46-107]
      OptionsList [52-107]
        OptionsEntry [53-64]
          Identifier(key) [53-56]
          StructConstructorWithParens [57-64]
            PathExpression [58-60]
              Identifier(c1) [58-60]
            PathExpression [61-63]
              Identifier(c2) [61-63]
        OptionsEntry [66-71]
          Identifier(ts) [66-68]
          PathExpression [69-71]
            Identifier(c3) [69-71]
        OptionsEntry [73-90]
          Identifier(ttl_type) [73-81]
          PathExpression [82-90]
            Identifier(absorlat) [82-90]
        OptionsEntry [92-106]
          Identifier(ttl) [92-95]
          StructConstructorWithParens [96-106]
            IntervalLiteral(10d) [97-100]
            IntLiteral(100) [102-105]
--
CREATE TABLE t
(
  c1 int32,
  c2 string,
  c3 int64,
  INDEX(key = (c1, c2), ts = c3, ttl_type = absorlat, ttl = (10d, 100))
)
==

# Treat FOREIGN KEY as an incomplete constraint definition rather than a valid
# column definition. (See also similar test for PRIMARY KEY.)
create table t (a int64, foreign key);
--
ERROR: Syntax error: Expected "(" but got ")" [at 1:37]
create table t (a int64, foreign key);
                                    ^
==

# Foreign key definitions must not have an empty column list.
create table t (a int64, foreign key ());
--
ERROR: Syntax error: Unexpected ")" [at 1:39]
create table t (a int64, foreign key ());
                                      ^
==

create table t (a int64, constraint c foreign key ());
--
ERROR: Syntax error: Unexpected ")" [at 1:52]
create table t (a int64, constraint c foreign key ());
                                                   ^
==

# Foreign key constraint keyword spelling check.
create table t (a int64, constrain c foreign key (a) references x (y));
--
ERROR: Syntax error: Expected CONSTRAINT for foreign key definition [at 1:26]
create table t (a int64, constrain c foreign key (a) references x (y));
                         ^
==

# Foreign key definitions must always have a REFERENCES clause.
create table t (a int64, foreign key (a));
--
ERROR: Syntax error: Expected keyword REFERENCES but got ")" [at 1:41]
create table t (a int64, foreign key (a));
                                        ^
==

create table t (a int64, constraint c foreign key (a));
--
ERROR: Syntax error: Expected keyword REFERENCES but got ")" [at 1:54]
create table t (a int64, constraint c foreign key (a));
                                                     ^
==

# Foreign key REFERENCES clause must have a table name.
create table t (a int64, foreign key (a) references (x));
--
ERROR: Syntax error: Unexpected "(" [at 1:53]
create table t (a int64, foreign key (a) references (x));
                                                    ^
==

create table t (a int64 references (x));
--
ERROR: Syntax error: Unexpected "(" [at 1:36]
create table t (a int64 references (x));
                                   ^
==

# Foreign key REFERENCES column list must not be empty.
create table t (a int64, foreign key (a) references x ());
--
ERROR: Syntax error: Unexpected ")" [at 1:56]
create table t (a int64, foreign key (a) references x ());
                                                       ^
==

# Foreign key REFERENCES column list must not be empty.
create table t (a int64 references x ());
--
ERROR: Syntax error: Unexpected ")" [at 1:39]
create table t (a int64 references x ());
                                      ^
==

# Foreign key enforcement cannot be used by itself.
create table t (a int64 not null enforced);
--
ERROR: Syntax error: Unexpected constraint enforcement clause [at 1:34]
create table t (a int64 not null enforced);
                                 ^
==

create table t (a int64 hidden not enforced);
--
ERROR: Syntax error: Unexpected constraint enforcement clause [at 1:32]
create table t (a int64 hidden not enforced);
                               ^
==

# Foreign key enforcement cannot be used by itself.
create table t (a int64 not enforced);
--
ERROR: Syntax error: Expected keyword NULL but got keyword ENFORCED [at 1:29]
create table t (a int64 not enforced);
                            ^
==

create table t (a int64 enforced);
--
ERROR: Syntax error: Expected ")" or "," but got keyword ENFORCED [at 1:25]
create table t (a int64 enforced);
                        ^
==

# Foreign key attributes and options are optional.
create table t (a int64, foreign key (a) references x (b));
--
CreateTableStatement [0-58]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-58]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int64) [18-23]
    ForeignKey [25-57]
      ColumnList [37-40]
        Identifier(a) [38-39]
      ForeignKeyReference(MATCH SIMPLE ENFORCED) [41-57]
        PathExpression [52-53]
          Identifier(x) [52-53]
        ColumnList [54-57]
          Identifier(b) [55-56]
        ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [57-57]
--
CREATE TABLE t
(
  a int64,
  FOREIGN KEY(a) REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED
)
==

create table t (a int64, foreign key (a) references x (b) options ());
--
CreateTableStatement [0-69]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-69]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int64) [18-23]
    ForeignKey [25-68]
      ColumnList [37-40]
        Identifier(a) [38-39]
      ForeignKeyReference(MATCH SIMPLE ENFORCED) [41-57]
        PathExpression [52-53]
          Identifier(x) [52-53]
        ColumnList [54-57]
          Identifier(b) [55-56]
        ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [57-57]
      OptionsList [66-68]
--
CREATE TABLE t
(
  a int64,
  FOREIGN KEY(a) REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED OPTIONS()
)
==

create table t (a int64, constraint c foreign key (a) references x (b));
--
CreateTableStatement [0-71]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-71]
    ColumnDefinition [16-23]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int64) [18-23]
    ForeignKey [25-70]
      ColumnList [50-53]
        Identifier(a) [51-52]
      ForeignKeyReference(MATCH SIMPLE ENFORCED) [54-70]
        PathExpression [65-66]
          Identifier(x) [65-66]
        ColumnList [67-70]
          Identifier(b) [68-69]
        ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [70-70]
      Identifier(c) [36-37]
--
CREATE TABLE t
(
  a int64,
  CONSTRAINT c FOREIGN KEY(a) REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED
)
==

create table t (
  a int64, constraint c foreign key (a) references x (b) options ());
--
CreateTableStatement [0-85]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-85]
    ColumnDefinition [19-26]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-26]
        PathExpression [21-26]
          Identifier(int64) [21-26]
    ForeignKey [28-84]
      ColumnList [53-56]
        Identifier(a) [54-55]
      ForeignKeyReference(MATCH SIMPLE ENFORCED) [57-73]
        PathExpression [68-69]
          Identifier(x) [68-69]
        ColumnList [70-73]
          Identifier(b) [71-72]
        ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [73-73]
      OptionsList [82-84]
      Identifier(c) [39-40]
--
CREATE TABLE t
(
  a int64,
  CONSTRAINT c FOREIGN KEY(a) REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED OPTIONS()
)
==

create table t (a int64 references x (b));
--
CreateTableStatement [0-41]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-41]
    ColumnDefinition [16-40]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-40]
        PathExpression [18-23]
          Identifier(int64) [18-23]
        ColumnAttributeList [23-40]
          ForeignKeyColumnAttribute [24-40]
            ForeignKeyReference(MATCH SIMPLE ENFORCED) [24-40]
              PathExpression [35-36]
                Identifier(x) [35-36]
              ColumnList [37-40]
                Identifier(b) [38-39]
              ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [40-40]
--
CREATE TABLE t
(
  a int64 REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED
)
==

create table t (a int64 references x (b) options ());
--
CreateTableStatement [0-52]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-52]
    ColumnDefinition [16-51]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-51]
        PathExpression [18-23]
          Identifier(int64) [18-23]
        ColumnAttributeList [23-40]
          ForeignKeyColumnAttribute [24-40]
            ForeignKeyReference(MATCH SIMPLE ENFORCED) [24-40]
              PathExpression [35-36]
                Identifier(x) [35-36]
              ColumnList [37-40]
                Identifier(b) [38-39]
              ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [40-40]
        OptionsList [49-51]
--
CREATE TABLE t
(
  a int64 REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED OPTIONS()
)
==

# Foreign key column references can precede other attributes. NOT NULL can
# erroneously conflict with NOT ENFORCED with some grammars (and potentially,
# although less likely, MATCH NOT DISTINCT). Ensure the grammar accepts
# NOT NULL following a foreign key reference.
create table t (a int64 references x (b) not null);
--
CreateTableStatement [0-50]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-50]
    ColumnDefinition [16-49]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-49]
        PathExpression [18-23]
          Identifier(int64) [18-23]
        ColumnAttributeList [23-49]
          ForeignKeyColumnAttribute [24-40]
            ForeignKeyReference(MATCH SIMPLE ENFORCED) [24-40]
              PathExpression [35-36]
                Identifier(x) [35-36]
              ColumnList [37-40]
                Identifier(b) [38-39]
              ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [40-40]
          NotNullColumnAttribute [41-49]
--
CREATE TABLE t
(
  a int64 REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED NOT NULL
)
==

create table t (a int64 references x (b) not enforced not null);
--
CreateTableStatement [0-63]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-63]
    ColumnDefinition [16-62]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-62]
        PathExpression [18-23]
          Identifier(int64) [18-23]
        ColumnAttributeList [23-62]
          ForeignKeyColumnAttribute [24-53]
            ForeignKeyReference(MATCH SIMPLE NOT ENFORCED) [24-40]
              PathExpression [35-36]
                Identifier(x) [35-36]
              ColumnList [37-40]
                Identifier(b) [38-39]
              ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [40-40]
          NotNullColumnAttribute [54-62]
--
CREATE TABLE t
(
  a int64 REFERENCES x(b) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT ENFORCED NOT NULL
)
==

create table t (a int64 references x (b) match not distinct not null);
--
CreateTableStatement [0-69]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-69]
    ColumnDefinition [16-68]
      Identifier(a) [16-17]
      SimpleColumnSchema [18-68]
        PathExpression [18-23]
          Identifier(int64) [18-23]
        ColumnAttributeList [23-68]
          ForeignKeyColumnAttribute [24-59]
            ForeignKeyReference(MATCH NOT DISTINCT ENFORCED) [24-59]
              PathExpression [35-36]
                Identifier(x) [35-36]
              ColumnList [37-40]
                Identifier(b) [38-39]
              ForeignKeyActions(ON UPDATE NO ACTION ON DELETE NO ACTION) [59-59]
          NotNullColumnAttribute [60-68]
--
CREATE TABLE t
(
  a int64 REFERENCES x(b) MATCH NOT DISTINCT ON UPDATE NO ACTION ON DELETE NO ACTION ENFORCED NOT NULL
)
==

# Check constraint.
create table t (
  a int64,
  b int64,
  check (a < b),
  check (a < b) enforced,
  check (a < b) not enforced,
  constraint check_a_and_b_1 check (a < b),
  constraint check_a_and_b_2 check (a < b) enforced,
  constraint check_a_and_b_3 check (a < b) not enforced
);
--
CreateTableStatement [0-266]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-266]
    ColumnDefinition [19-26]
      Identifier(a) [19-20]
      SimpleColumnSchema [21-26]
        PathExpression [21-26]
          Identifier(int64) [21-26]
    ColumnDefinition [30-37]
      Identifier(b) [30-31]
      SimpleColumnSchema [32-37]
        PathExpression [32-37]
          Identifier(int64) [32-37]
    CheckConstraint(ENFORCED) [41-54]
      BinaryExpression(<) [48-53]
        PathExpression [48-49]
          Identifier(a) [48-49]
        PathExpression [52-53]
          Identifier(b) [52-53]
    CheckConstraint(ENFORCED) [58-80]
      BinaryExpression(<) [65-70]
        PathExpression [65-66]
          Identifier(a) [65-66]
        PathExpression [69-70]
          Identifier(b) [69-70]
    CheckConstraint(NOT ENFORCED) [84-110]
      BinaryExpression(<) [91-96]
        PathExpression [91-92]
          Identifier(a) [91-92]
        PathExpression [95-96]
          Identifier(b) [95-96]
    CheckConstraint(ENFORCED) [114-154]
      BinaryExpression(<) [148-153]
        PathExpression [148-149]
          Identifier(a) [148-149]
        PathExpression [152-153]
          Identifier(b) [152-153]
      Identifier(check_a_and_b_1) [125-140]
    CheckConstraint(ENFORCED) [158-207]
      BinaryExpression(<) [192-197]
        PathExpression [192-193]
          Identifier(a) [192-193]
        PathExpression [196-197]
          Identifier(b) [196-197]
      Identifier(check_a_and_b_2) [169-184]
    CheckConstraint(NOT ENFORCED) [211-264]
      BinaryExpression(<) [245-250]
        PathExpression [245-246]
          Identifier(a) [245-246]
        PathExpression [249-250]
          Identifier(b) [249-250]
      Identifier(check_a_and_b_3) [222-237]
--
CREATE TABLE t
(
  a int64,
  b int64,
  CHECK(a < b) ENFORCED,
  CHECK(a < b) ENFORCED,
  CHECK(a < b) NOT ENFORCED,
  CONSTRAINT check_a_and_b_1 CHECK(a < b) ENFORCED,
  CONSTRAINT check_a_and_b_2 CHECK(a < b) ENFORCED,
  CONSTRAINT check_a_and_b_3 CHECK(a < b) NOT ENFORCED
)
==

# Backward compatiblity: 'check' is non-reserved keyword; make sure we don't
# fail on existing table using 'check' as either table name or column name.
create table check (check int64);
--
CreateTableStatement [0-32]
  PathExpression [13-18]
    Identifier(check) [13-18]
  TableElementList [19-32]
    ColumnDefinition [20-31]
      Identifier(check) [20-25]
      SimpleColumnSchema [26-31]
        PathExpression [26-31]
          Identifier(int64) [26-31]
--
CREATE TABLE check
(
  check int64
)
==

# Backward compatibility: 'constraint' as either table name or column name.
create table constraint (constraint int64);
--
CreateTableStatement [0-42]
  PathExpression [13-23]
    Identifier(constraint) [13-23]
  TableElementList [24-42]
    ColumnDefinition [25-41]
      Identifier(constraint) [25-35]
      SimpleColumnSchema [36-41]
        PathExpression [36-41]
          Identifier(int64) [36-41]
--
CREATE TABLE constraint
(
  constraint int64
)
==

# constraint with name int64 instead of column with type int64
create table t (
  constraint int64 check(check>0)
);
--
CreateTableStatement [0-52]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-52]
    CheckConstraint(ENFORCED) [19-50]
      BinaryExpression(>) [42-49]
        PathExpression [42-47]
          Identifier(check) [42-47]
        IntLiteral(0) [48-49]
      Identifier(int64) [30-35]
--
CREATE TABLE t
(
  CONSTRAINT int64 CHECK(check > 0) ENFORCED
)
==

# constraint with name array is parsed as column with type array
create table t (
  constraint array check(check>0)
);
--
ERROR: Syntax error: Expected "<" but got keyword CHECK [at 2:20]
  constraint array check(check>0)
                   ^
==

# constraint with name array in backticks
create table t (
  constraint `array` check(check>0)
);
--

CreateTableStatement [0-54]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-54]
    CheckConstraint(ENFORCED) [19-52]
      BinaryExpression(>) [44-51]
        PathExpression [44-49]
          Identifier(check) [44-49]
        IntLiteral(0) [50-51]
      Identifier(`array`) [30-37]
--
CREATE TABLE t
(
  CONSTRAINT `array` CHECK(check > 0) ENFORCED
)
==

# constraint with name struct is parsed as column with struct
create table t (
  constraint struct check(check>0)
);
--
ERROR: Syntax error: Expected "<" but got keyword CHECK [at 2:21]
  constraint struct check(check>0)
                    ^
==

# constraint with name struct in backticks
create table t (
  constraint `struct` check(check>0)
);
--
CreateTableStatement [0-55]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-55]
    CheckConstraint(ENFORCED) [19-53]
      BinaryExpression(>) [45-52]
        PathExpression [45-50]
          Identifier(check) [45-50]
        IntLiteral(0) [51-52]
      Identifier(`struct`) [30-38]
--
CREATE TABLE t
(
  CONSTRAINT `struct` CHECK(check > 0) ENFORCED
)
==

# constraint named reserved key word proto, which can't be used as identifier.
create table t (
  constraint proto check(check>0)
);
--
ERROR: Syntax error: Unexpected keyword PROTO [at 2:14]
  constraint proto check(check>0)
             ^
==

# constraint named proto with backticks
create table t (
  constraint `proto` check(check>0)
);
--
CreateTableStatement [0-54]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-54]
    CheckConstraint(ENFORCED) [19-52]
      BinaryExpression(>) [44-51]
        PathExpression [44-49]
          Identifier(check) [44-49]
        IntLiteral(0) [50-51]
      Identifier(`proto`) [30-37]
--
CREATE TABLE t
(
  CONSTRAINT `proto` CHECK(check > 0) ENFORCED
)
==

# constraint with name timestamp
create table t (
  constraint timestamp check(check>0)
);
--
CreateTableStatement [0-56]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-56]
    CheckConstraint(ENFORCED) [19-54]
      BinaryExpression(>) [46-53]
        PathExpression [46-51]
          Identifier(check) [46-51]
        IntLiteral(0) [52-53]
      Identifier(timestamp) [30-39]
--
CREATE TABLE t
(
  CONSTRAINT timestamp CHECK(check > 0) ENFORCED
)
==

# constraint with multi part name not allowed
create table t (
  constraint a.b.c check(check>0)
);
--
ERROR: Syntax error: Expected ")" or "," but got keyword CHECK [at 2:20]
  constraint a.b.c check(check>0)
                   ^
==

# column with multi part name type
create table t (
  constraint a.b.c not null
);
--
CreateTableStatement [0-46]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-46]
    ColumnDefinition [19-44]
      Identifier(constraint) [19-29]
      SimpleColumnSchema [30-44]
        PathExpression [30-35]
          Identifier(a) [30-31]
          Identifier(b) [32-33]
          Identifier(c) [34-35]
        ColumnAttributeList [36-44]
          NotNullColumnAttribute [36-44]
--
CREATE TABLE t
(
  constraint a.b.c NOT NULL
)
==

# Both 'check' and 'constraint' are non-reserved keyword and they can appear as
# constraint name.
create table t (
  check int64,
  constraint int64,
  constraint check check (check > 0),
  constraint constraint check (constraint > 0)
);
--
CreateTableStatement [0-138]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-138]
    ColumnDefinition [19-30]
      Identifier(check) [19-24]
      SimpleColumnSchema [25-30]
        PathExpression [25-30]
          Identifier(int64) [25-30]
    ColumnDefinition [34-50]
      Identifier(constraint) [34-44]
      SimpleColumnSchema [45-50]
        PathExpression [45-50]
          Identifier(int64) [45-50]
    CheckConstraint(ENFORCED) [54-88]
      BinaryExpression(>) [78-87]
        PathExpression [78-83]
          Identifier(check) [78-83]
        IntLiteral(0) [86-87]
      Identifier(check) [65-70]
    CheckConstraint(ENFORCED) [92-136]
      BinaryExpression(>) [121-135]
        PathExpression [121-131]
          Identifier(constraint) [121-131]
        IntLiteral(0) [134-135]
      Identifier(constraint) [103-113]
--
CREATE TABLE t
(
  check int64,
  constraint int64,
  CONSTRAINT check CHECK(check > 0) ENFORCED,
  CONSTRAINT constraint CHECK(constraint > 0) ENFORCED
)
==

# Syntax errors for check constraint.
# Column constraint is not supported yet. Thus first identifier must be
# 'CONSTRAINT', if the third token is 'CHECK'.
create table t (
  a int64 check (a > 0)
);
--
ERROR: Syntax error: Expected CONSTRAINT for check constraint definition. Check constraints on columns are not supported. Define check constraints as table elements instead [at 2:3]
  a int64 check (a > 0)
  ^
==

create table t (
  a int64,
  check
);
--
ERROR: Syntax error: Unexpected ")" [at 4:1]
);
^
==

create table t (
  a int64,
  check ()
);
--
ERROR: Syntax error: Unexpected ")" [at 3:10]
  check ()
         ^
==

create table t (
  a int64,
  check (a > 0) check (a < 100)
);
--
ERROR: Syntax error: Expected ")" or "," but got keyword CHECK [at 3:17]
  check (a > 0) check (a < 100)
                ^
==

create table t (
  a int64,
  check (a > 0) not
);
--
ERROR: Syntax error: Expected keyword ENFORCED but got ")" [at 4:1]
);
^
==

create table t (
  a int64,
  constraint check (a > 0)
);
--
ERROR: Syntax error: Unexpected identifier "a" [at 3:21]
  constraint check (a > 0)
                    ^
==

[no_test_get_parse_tokens]
[{{no_|}}allow_dashed_table_names]
create table p-123.x.t1 (a int32, b string);
--
ALTERNATION GROUP: no_
--
ERROR: Syntax error: Table name contains '-' character. It needs to be quoted: `p-123.x.t1` [at 1:14]
create table p-123.x.t1 (a int32, b string);
             ^
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-43]
  PathExpression [13-23]
    Identifier(`p-123`) [13-20]
    Identifier(x) [13-20]
    Identifier(t1) [21-23]
  TableElementList [24-43]
    ColumnDefinition [25-32]
      Identifier(a) [25-26]
      SimpleColumnSchema [27-32]
        PathExpression [27-32]
          Identifier(int32) [27-32]
    ColumnDefinition [34-42]
      Identifier(b) [34-35]
      SimpleColumnSchema [36-42]
        PathExpression [36-42]
          Identifier(string) [36-42]
--
CREATE TABLE `p-123`.x.t1
(
  a int32,
  b string
)
==

create {{|temporary|external}} table t1
(a int64,) options ()
--
ALTERNATION GROUP: <empty>
--
CreateTableStatement [0-38]
  PathExpression [14-16]
    Identifier(t1) [14-16]
  TableElementList [17-27]
    ColumnDefinition [18-25]
      Identifier(a) [18-19]
      SimpleColumnSchema [20-25]
        PathExpression [20-25]
          Identifier(int64) [20-25]
  OptionsList [36-38]
--
CREATE TABLE t1
(
  a int64
) OPTIONS()
--
ALTERNATION GROUP: temporary
--
CreateTableStatement(is_temp) [0-47]
  PathExpression [23-25]
    Identifier(t1) [23-25]
  TableElementList [26-36]
    ColumnDefinition [27-34]
      Identifier(a) [27-28]
      SimpleColumnSchema [29-34]
        PathExpression [29-34]
          Identifier(int64) [29-34]
  OptionsList [45-47]
--
CREATE TEMP TABLE t1
(
  a int64
) OPTIONS()
--
ALTERNATION GROUP: external
--
CreateExternalTableStatement [0-46]
  PathExpression [22-24]
    Identifier(t1) [22-24]
  TableElementList [25-35]
    ColumnDefinition [26-33]
      Identifier(a) [26-27]
      SimpleColumnSchema [28-33]
        PathExpression [28-33]
          Identifier(int64) [28-33]
  OptionsList [44-46]
--
CREATE EXTERNAL TABLE t1
(
  a int64
) OPTIONS()
==

create table t1 (a int64, b string,);
--
CreateTableStatement [0-36]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-36]
    ColumnDefinition [17-24]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-24]
        PathExpression [19-24]
          Identifier(int64) [19-24]
    ColumnDefinition [26-34]
      Identifier(b) [26-27]
      SimpleColumnSchema [28-34]
        PathExpression [28-34]
          Identifier(string) [28-34]
--
CREATE TABLE t1
(
  a int64,
  b string
)

==

create table t1 (a int64, b string) with partition columns;
--
ERROR: Syntax error: Expected end of input but got keyword WITH [at 1:37]
create table t1 (a int64, b string) with partition columns;
                                    ^

==

create table t1 (a interval, b `Interval`, c int64);
--
CreateTableStatement [0-51]
  PathExpression [13-15]
    Identifier(t1) [13-15]
  TableElementList [16-51]
    ColumnDefinition [17-27]
      Identifier(a) [17-18]
      SimpleColumnSchema [19-27]
        PathExpression [19-27]
          Identifier(`interval`) [19-27]
    ColumnDefinition [29-41]
      Identifier(b) [29-30]
      SimpleColumnSchema [31-41]
        PathExpression [31-41]
          Identifier(`Interval`) [31-41]
    ColumnDefinition [43-50]
      Identifier(c) [43-44]
      SimpleColumnSchema [45-50]
        PathExpression [45-50]
          Identifier(int64) [45-50]
--
CREATE TABLE t1
(
  a interval,
  b Interval,
  c int64
)

==

# Parameterized type: STRING(L), NUMERIC(P,S)
create table table1
(
  c1 string(100),
  c2 numeric(10, 5),
  c3 array<string(MAX)>,
  c4 struct<f1 string(100), f2 numeric(10)>
);

--
CreateTableStatement [0-131]
  PathExpression [13-19]
    Identifier(table1) [13-19]
  TableElementList [20-131]
    ColumnDefinition [24-38]
      Identifier(c1) [24-26]
      SimpleColumnSchema [27-38]
        PathExpression [27-33]
          Identifier(string) [27-33]
        TypeParameterList [33-37]
          IntLiteral(100) [34-37]
    ColumnDefinition [42-59]
      Identifier(c2) [42-44]
      SimpleColumnSchema [45-59]
        PathExpression [45-52]
          Identifier(numeric) [45-52]
        TypeParameterList [52-58]
          IntLiteral(10) [53-55]
          IntLiteral(5) [57-58]
    ColumnDefinition [63-84]
      Identifier(c3) [63-65]
      ArrayColumnSchema [66-84]
        SimpleColumnSchema [72-83]
          PathExpression [72-78]
            Identifier(string) [72-78]
          TypeParameterList [78-82]
            MaxLiteral() [79-82]
    ColumnDefinition [88-129]
      Identifier(c4) [88-90]
      StructColumnSchema [91-129]
        StructColumnField [98-112]
          Identifier(f1) [98-100]
          SimpleColumnSchema [101-112]
            PathExpression [101-107]
              Identifier(string) [101-107]
            TypeParameterList [107-111]
              IntLiteral(100) [108-111]
        StructColumnField [114-128]
          Identifier(f2) [114-116]
          SimpleColumnSchema [117-128]
            PathExpression [117-124]
              Identifier(numeric) [117-124]
            TypeParameterList [124-127]
              IntLiteral(10) [125-127]

--
CREATE TABLE table1
(
  c1 string(100),
  c2 numeric(10, 5),
  c3 ARRAY< string(MAX) >,
  c4 STRUCT< f1 string(100), f2 numeric(10) >
)

==

# Create table with float literal type parameter.
CREATE TABLE table1
(
  c1 string(1.1)
)
--
CreateTableStatement [0-40]
  PathExpression [13-19]
    Identifier(table1) [13-19]
  TableElementList [20-40]
    ColumnDefinition [24-38]
      Identifier(c1) [24-26]
      SimpleColumnSchema [27-38]
        PathExpression [27-33]
          Identifier(string) [27-33]
        TypeParameterList [33-37]
          FloatLiteral(1.1) [34-37]
--
CREATE TABLE table1
(
  c1 string(1.1)
)
==

# Type parameter can not be a expression with MAX().
CREATE TABLE t2 (c1 numeric(MAX(), 10))

--
ERROR: Syntax error: Expected ")" or "," but got "(" [at 1:32]
CREATE TABLE t2 (c1 numeric(MAX(), 10))
                               ^
==

# Type parameter can not be a expression.
CREATE TABLE t1 (c1 string(10 + 20))

--
ERROR: Syntax error: Expected ")" or "," but got "+" [at 1:31]
CREATE TABLE t1 (c1 string(10 + 20))
                              ^
==

# CREATE TABLE CLONE
create table t CLONE t1;
--
CreateTableStatement [0-23]
  PathExpression [13-14]
    Identifier(t) [13-14]
  CloneDataSource [21-23]
    PathExpression [21-23]
      Identifier(t1) [21-23]
--
CREATE TABLE t CLONE
t1
==

create external table t CLONE t1 OPTIONS();
--

ERROR: Syntax error: Expected keyword OPTIONS [at 1:24]
create external table t CLONE t1 OPTIONS();
                       ^

==

# CREATE TABLE CLONE with column list, valid for parser and Resolver will catch
# the co-existence of LIKE and column list.
create table t (x int64) CLONE t1;
--

CreateTableStatement [0-33]
  PathExpression [13-14]
    Identifier(t) [13-14]
  TableElementList [15-24]
    ColumnDefinition [16-23]
      Identifier(x) [16-17]
      SimpleColumnSchema [18-23]
        PathExpression [18-23]
          Identifier(int64) [18-23]
  CloneDataSource [31-33]
    PathExpression [31-33]
      Identifier(t1) [31-33]

--
CREATE TABLE t
(
  x int64
) CLONE
t1
==

# CREATE TABLE CLONE without table name.
create table t clone;
--
ERROR: Syntax error: Unexpected ";" [at 1:21]
create table t clone;
                    ^
==

# CREATE TABLE CLONE with FOR SYSTEM_TIME AS OF
create table t CLONE t1 for system_time as of CURRENT_TIMESTAMP();
--


CreateTableStatement [0-65]
  PathExpression [13-14]
    Identifier(t) [13-14]
  CloneDataSource [21-65]
    PathExpression [21-23]
      Identifier(t1) [21-23]
    ForSystemTime [24-65]
      FunctionCall [46-65]
        PathExpression [46-63]
          Identifier(`CURRENT_TIMESTAMP`) [46-63]
--
CREATE TABLE t CLONE
t1
  FOR SYSTEM_TIME AS OF `CURRENT_TIMESTAMP`()

==

# CREATE TABLE CLONE with OPTIONS
create table t CLONE t1 OPTIONS(
    expiration_timestamp=TIMESTAMP "2019-05-22 00:00:00 UTC",
    description="mydataset.source_table clone",
    label=[("experiments")]
)
--


CreateTableStatement [0-172]
  PathExpression [13-14]
    Identifier(t) [13-14]
  CloneDataSource [21-23]
    PathExpression [21-23]
      Identifier(t1) [21-23]
  OptionsList [31-172]
    OptionsEntry [37-93]
      Identifier(expiration_timestamp) [37-57]
      DateOrTimeLiteral(TYPE_TIMESTAMP) [58-93]
        StringLiteral("2019-05-22 00:00:00 UTC") [68-93]
    OptionsEntry [99-141]
      Identifier(description) [99-110]
      StringLiteral("mydataset.source_table clone") [111-141]
    OptionsEntry [147-170]
      Identifier(label) [147-152]
      ArrayConstructor [153-170]
        StringLiteral("experiments") [155-168]
--
CREATE TABLE t CLONE
t1
OPTIONS(expiration_timestamp = TIMESTAMP "2019-05-22 00:00:00 UTC", description = "mydataset.source_table clone",
  label = ARRAY["experiments"])
